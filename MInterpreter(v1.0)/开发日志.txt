20220629
创建工程。下午写完词法分析完成验证。读文件不想往回倒，所以有时会出现多余的字符，比如读iden或者常量后边跟着个+，再比如读>后面跟着的是个字母，这些多余的字符会留着下次
循环用，但是如果本次读词的所有字符都用到了，就要给字符类别清零，这样下次循环时就知道要重读了。尤其是读一半到文件结尾了，这时也要清零，不然下次再进来会认为是上次遗留了
有效字符而陷入死循环。

晚上开发完四元式，写了移进，在写归约。总体控制语句有待完善，但我爆肝实在太困了。23：56
结束条件可以是这样，读完了，lastToken为NONE，category给;，这样能保证完成语句归约，acc时判断lastToken为NONE就知道翻译结束了。m_word也只用于看着玩了，判断是否要取词
用lastToken判，或者像词法分析一样判category
20220630
今天实现了部分四元式生成。下午到晚上调试bug，主要有两点：
1.现在E有三种了，而且写四元式时不再转回去，比如_TOKEN_E_CONST_不再转回_TOKEN_CONST_，但是旧代码没更新，导致一些问题；
2.语义栈种别码错写成column号，统一写token号，因为token号比column号承载了更多信息，column号为了精简LR表合并了很多东西；
此外还有一些小bug，比如语义栈弄错了，E->var取了stack.size()-2这样莫名其妙的笔误，明明是stack.size()-1

搞明白了点东西，首先就是vector的reserve，很显然嘛，顺序表预订的堆内存，之前咋就不明白呢，push_back一旦超过这个范围就要new新的空间，delete旧空间，此时会发生构造析构
string str;不能直接printf(str);要prinf(str.data()); cout<< str << endl;也可以。估计c++的ostream也可以，以后学习下c++的写文件。
vector空的时候pop会报错

能打印四元式和词法分析了。用制表符排了下版。
push_back时拷贝构造函数

0：42，完成了各种运算的翻译，明天翻译重头戏，if和while
有个问题，-可能是一元运算，判操作数2，种别码为0
20220701
早晨增加了打印语句的翻译，有两种，赋值以;结尾，赋值并输出；只有一个变量，单独产生一条输出四元式。
截至傍晚，完成了while的翻译。但是有内存泄漏。早晨的基本运算没问题，应该是while这里的问题。
半夜1：34，解决了内存泄漏问题，原因在于，void* m_ptr = new list<QUADNUM>; delete m_ptr;无法完全释放list的空间，因为编译器只认识m_ptr开头的一块内存，但显然list里面
是有很多new的。解决方案是delete (list<QUADNUM>*)m_ptr;
20220702
中午完成了复合语句的翻译
const int** ptr修饰的int,**ptr不能变。下来搞明白const和指针

写两点感想：1.Token中name和nextlist指针应该分开，多4个字节而已，可读性会好很多，逻辑会简单很多，以及意外的bug会少很多，昨晚费半天劲就是找的这个bug。
就算共用指针，返回指针的类成员函数也应该分开，按返回值意义写清楚
2.状态不要用太多兜底，不然错误不好查，失去了状态字的意义，像口袋罪一样
3.应该边开发边考虑重复使用
4.写计算这部分时，解释+就是+，解释-就是-，解释^就是调pow函数，突然迷茫了，解释器干啥用的？简化c++吗。
5.typedef也可以当注释，比如QUADNUM，一眼就知道是四元式编号相关

今天下午完成了后端计算，晚上一直在弄界面，凑合着可以算初稿了，但明天还得继续改。
Edit里\n不管用，得\r\n才换行
2：48
需要加
1.clear
2.读文件改读字符串
3.键盘响应（路径+命令行）
4.重复解释以及命令行

setfullscreen电脑直接重启了。。。
20220703
打开文件返回值可以细化，加上可以解析但没有debug文件
1：53昨天要改的东西都改完了。clear clc硬塞到break里，还改了0遇到break的语法动作，允许移进，报错留到后边；加了报错信息打印
改了一堆bug
2：02第一版算是写完了
20220731
解决了之前没空解决的小问题：命令行前两个字符>>只读；历史窗口完全只读。继承CEdit类，成员变量控制只读字符数，完成。
20220802
试图优化临时变量号分配算法，太烧脑放弃了。当前算法是如果两操作数存在临时变量，结果取临时变量编号较大值，否则取当前所有最大编号+1.
这个算法一定是没问题的。所谓问题，就是新的结果用了旧的还有意义的临时变量编号。
当前算法一定不会出现问题。用最大编号+1不会出问题，用较大编号的话，旧临时变量使命已完成，也不会出问题。

写了内置函数文法，暂时不写自定义函数。明早检查一下，开始写代码。更改内容为：识别完var的项目，以及由于识别参数列表新增的项目
20220803
早晨检查了内置函数文法，果然发现了问题。主要在于，增加了新的符号后，还要对旧的归约项进行检查。比如增加了逗号后，所有E的产生式在遇到逗号时也要归约。
20220806
又被叫去干活。。。进度缓慢。今天完成了CToken的修改，主要是把之前的一个指针拆分开，重新写了各个接口。
四元式类改成了4CToken又改回来了，因为感觉现在打印的四元式挺合理的，而且jmp jz =这些操作附带参数放到到result里似乎也挺合理，跳转地址算结果，打印输出也凑合算结果吧。
最重要的是省得改来改去浪费时间。四元式仍然是整型操作码，但是优化了可读性。
以后多用ASSERT，Release下不编译。
明天解决一下clear放开头报错的问题。
20220807
修改文法，解决了acc识别clear报错的bug。初始工作路径由C:\\Windows\\System32(抄来的matlab默认路径)改为exe所在路径。